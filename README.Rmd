---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
library(baizer)
library(badger)
```

# baizer <img src="man/figures/logo.png" align="right" />

<!-- badges: start -->
[![Codecov test coverage](https://codecov.io/gh/william-swl/baizer/branch/master/graph/badge.svg)](https://app.codecov.io/gh/william-swl/baizer?branch=master)
[![R-CMD-check](https://github.com/william-swl/baizer/actions/workflows/check-standard.yaml/badge.svg)](https://github.com/william-swl/baizer/actions/workflows/check-standard.yaml)
`r badge_cran_release("baizer", "orange")`
`r badge_devel("william-swl/baizer", "blue")`
`r badge_cran_download("baizer", "grand-total", "blue")`
`r badge_cran_download("baizer", "last-month", "green")`
<!-- badges: end -->

- In ancient Chinese mythology, Bai Ze is a divine creature that knows the needs of everything.
- `baizer` provides data processing functions frequently used by the author.
- Hope this package also knows what you want!

## installation

You can install the stable version of `baizer` like so:

``` r
install.packages("baizer")
```

Or install the development version of `baizer` like so:

``` r
devtools::install_github("william-swl/baizer")
```

## S3 classes in `baizer`
### tbflt
- save a series of filter conditions, and support 
logical operation among conditions
- use `filterC` to apply `tbflt` on `dplyr::filter`

``` {r tbflt}
c1 <- tbflt(cut == "Fair")
c2 <- tbflt(x > 8)
c1 | c2

mini_diamond %>%
  filterC(c1) %>%
  head(5)

mini_diamond %>%
  filterC(!c1) %>%
  head(5)

mini_diamond %>% filterC(c1 & c2)
```

- stricter limitation to avoid the unexpected default behavior
```{r tbflt-uscol}
# default behavior of dplyr::filter, use column in data at first
x <- 8
mini_diamond %>% dplyr::filter(y > x)

# so the default behavior of filterC is just like that
# but if you want y > 8, and the defination of cond is far away from
# its application, the results may be unexpected

x <- 8
cond <- tbflt(y > x)
mini_diamond %>% filterC(cond)

cond <- tbflt(y > 8)
mini_diamond %>% filterC(cond)


# to avoid this, set usecol=FALSE. An error will be raised for warning you
# to change the variable name
# mini_diamond %>% filterC(cond, usecol=FALSE)


# you can always ignore this argument if you know how to use .env or !!
x <- 8
cond1 <- tbflt(y > !!x)
mini_diamond %>% filterC(cond1)

cond2 <- tbflt(y > .env$x)
mini_diamond %>% filterC(cond1)
```



## basic utils
- load packages as a batch
```{r basic-utils-pkglib}
baizer::pkglib(dplyr, purrr)
```

- versions of packages
```{r basic-utils-pkgver}
baizer::pkgver(dplyr, purrr)
```

- information of packages
```{r basic-utils-pkginfo}
baizer::pkginfo(dplyr)
```


- use `%nin%` to get 'not in' logical value
```{r basic-utils-nin}
1 %nin% c(1, 2, 3)

1 %nin% c(2, 3)
```

- use `%neq%` to get `NA` supported 'not equal' logical value
```{r basic-utils-neq}
NA != 0

NA != NA

NA %neq% 0

NA %neq% NA
```

- dump a vector into string
```{r basic-utils-collapse_vector}
collapse_vector(c("A" = 2, "B" = 3, "C" = 4), front_name = TRUE, collapse = ";")

collapse_vector(c("A" = 2, "B" = 3, "C" = 4), front_name = FALSE, collapse = ",")
```

- the index of different character
```{r basic-utils-diff_index}
diff_index("AAAA", "ABBA")

# ignore case
diff_index("AAAA", "abba", ignore_case = TRUE)

# only the index of nth different character, NA if unaccessible
diff_index("AAAA", "ABBA", nth = 2)

diff_index("AAAA", "ABBA", 10)

# second and third indices
diff_index("AAAA", "ABBB", nth = 2:3)

# support vectorized operations
diff_index(c("ABBA", "AABB"), "AAAA")
```

- the index of same character
```{r basic-utils-same_index}
# just like diff_index
same_index(c("ABBA", "AABB"), "AAAA")
```


- fetch character from strings
```{r basic-utils-fetch_char}
fetch_char(rep("ABC", 3), list(1, 2, 3))

# accept the output of `diff_index` or `same_index`
str1 <- c("ABCD", "AAEF")
str2 <- c("AAAA", "AAAA")
fetch_char(str1, diff_index(str1, str2))

# if the output of `diff_index` have NA, also return NA
fetch_char(str1, diff_index(str1, str2, nth = 1:3), na.rm = FALSE)

# remove NA
fetch_char(str1, diff_index(str1, str2, nth = 1:5), na.rm = TRUE)

# collapse the characters from a same string
fetch_char(str1, diff_index(str1, str2, nth = 1:5), na.rm = TRUE, collapse = ",")
```

- trans fixed string into regular expression string
```{r basic-utils-fix_to_regex}
fix_to_regex("ABC|?(*)")
```

- detect possible duplication in a vector, ignore case, blank and special character
```{r basic-utils-detect_dup}
detect_dup(c("a", "B", "C_", "c -", "#A"))
```

- extract key and values for a character vector
```{r basic-utils-extract_kv}
extract_kv(c("x: 1", "y: 2"))
```

- farthest point sampling (FPS) for a vector
```{r basic-utils-fps_vector}
fps_vector(1:10, 2)

fps_vector(1:10, 4)

fps_vector(c(1, 2, NULL), 2)

fps_vector(c(1, 2, NA), 2)
```


- regex match
```{r basic-utils-reg_match}
v <- stringr::str_c("id", 1:3, c("A", "B", "C"))
v

# return first group as default
reg_match(v, "id(\\d+)(\\w)")

reg_match(v, "id(\\d+)(\\w)", group = 2)

# when group=-1, return full matched tibble
reg_match(v, "id(\\d+)(\\w)", group = -1)
```


- split vector into list
```{r basic-utils-split_vector}
split_vector(1:10, c(3, 7))


vec <- stringr::str_split("ABCDEFGHIJ", "") %>% unlist()
vec

split_vector(vec, breaks = c(3, 7), bounds = "[)")
```

- group chracter vector by a regex pattern
```{r basic-utils-group_vector}
v <- c(
  stringr::str_c("A", c(1, 2, 9, 10, 11, 12, 99, 101, 102)),
  stringr::str_c("B", c(1, 2, 9, 10, 21, 32, 99, 101, 102))
) %>% sample()
v

group_vector(v)

group_vector(v, pattern = "\\w\\d")

# the pattern rules are just same as reg_match()
group_vector(v, pattern = "\\w(\\d)")

# unmatched part will alse be stored
group_vector(v, pattern = "\\d{2}")
```


- sort by a function
```{r basic-utils-sortf}
sortf(c(-2, 1, 3), abs)

v <- stringr::str_c("id", c(1, 2, 9, 10, 11, 12, 99, 101, 102)) %>% sample()
v

sortf(v, function(x) reg_match(x, "\\d+") %>% as.double())

# you can also use purrr functions
sortf(v, ~ reg_match(.x, "\\d+") %>% as.double())


# group before sort
v <- c(
  stringr::str_c("A", c(1, 2, 9, 10, 11, 12, 99, 101, 102)),
  stringr::str_c("B", c(1, 2, 9, 10, 21, 32, 99, 101, 102))
) %>% sample()
v

sortf(v, ~ reg_match(.x, "\\d+") %>% as.double(), group_pattern = "\\w")
```

- pileup another logical vector on the TRUE values of first vector
```{r basic-utils-pileup_logical}
# first vector have 2 TRUE value
v1 <- c(TRUE, FALSE, TRUE)

# the length of second vector should also be 2
v2 <- c(FALSE, TRUE)

pileup_logical(v1, v2)
```

- only keep unique vector values and its names

```{r basic-utils-uniq}
v <- c(a = 1, b = 2, c = 3, b = 2, a = 1)

# unique will lost the names
unique(v)

# uniq can keep them
uniq(v)
```


## numbers

- from float number to fixed digits character
```{r numbers-round_signif}
round(2.1951, 2)

round_string(2.1951, 2)

signif(2.1951, 3)

signif_string(2.1951, 3)
```

- signif or round string depend on the character length
```{r numbers-signif_round_string}
signif_round_string(20.526, 2, "short")
signif_round_string(20.526, 2, "long")

# if you want keep the very small value
signif_round_string(0.000002654, 3, full_small = TRUE)
```

- signif while use floor/ceiling
```{r numbers-signif_floor}
signif_floor(3.19, 2)

signif_ceiling(3.11, 2)
```


- whether the number string only has zero
```{r numbers-iszero}
is.zero("0.000")

is.zero("0.0001")
```


- float and percent trans
```{r numbers-float_percent}
float_to_percent(0.123, digits = 1)

percent_to_float("123%", digits = 3)

percent_to_float("123%", digits = 3, to_double = TRUE)
```

- wrapper of the functions to process number string with prefix and suffix
```{r numbers-number_fun_wrapper}
number_fun_wrapper(">=2.134%", function(x) round(x, 2))
```

- expand a number vector according to the adjacent two numbers
```{r numbers-adjacent_div}
adjacent_div(10^c(1:3), n_div = 10)

# only keep the unique numbers
adjacent_div(10^c(1:3), n_div = 10, .unique = TRUE)
```

- correct the numbers to a target ratio
```{r numbers-correct_ratio}
correct_ratio(c(10, 10), c(3, 5))

# support ratio as a float
correct_ratio(c(100, 100), c(0.2, 0.8))

# more numbers
correct_ratio(10:13, c(2, 3, 4, 6))

# with digits after decimal point
correct_ratio(c(10, 10), c(1, 4), digits = 1)
```

- the ticks near a number
```{r numbers-near_ticks}
near_ticks(3462, level = 10)
```

- the nearest ticks around a number
```{r numbers-nearest_tick}
nearest_tick(3462, level = 10)
```

- generate ticks for a number vector

```{r numbers-generate_ticks}
generate_ticks(c(176, 198, 264))
```

- split a positive integer number as a number vector
```{r numbers-pos_int_split}
pos_int_split(12, 3, method = "average")

pos_int_split(12, 3, method = "random")

# you can also assign the ratio of output
pos_int_split(12, 3, method = c(1, 2, 3))
```

- generate outliers from a series of number
```{r numbers-gen_outlier}
x <- seq(0, 100, 1)

gen_outlier(x, 10)

# generation limits
gen_outlier(x, 10, lim = c(-80, 160))

# assign the left and right outliers
gen_outlier(x, 10, lim = c(-80, 160), assign_n = c(0.1, 0.9))

# just generate left outliers
gen_outlier(x, 10, side = "left")
```


## dataframe
- a minimal dataset
```{r dataframe-mini_diamond}
head(mini_diamond)
```

- shortcut of `dplyr::column_to_rownames` and `dplyr::rownames_to_column`
```{r dataframe-cr}
head(mini_diamond) %>% c2r("id")

# use column index
head(mini_diamond) %>% c2r(1)

head(mini_diamond) %>%
  c2r("id") %>%
  r2c("id")
```

- fancy count to show an extended column
```{r dataframe-fancy_count}

# count one column
fancy_count(mini_diamond, cut)

# count an extended column
fancy_count(mini_diamond, cut, ext = clarity)

# change format
fancy_count(mini_diamond, cut, ext = clarity, ext_fmt = "ratio")

fancy_count(mini_diamond, cut, ext = clarity, ext_fmt = "clean")

# count an extended column, in an order by n
fancy_count(mini_diamond, cut, ext = clarity, sort = TRUE)

# extended column after a two-column count
fancy_count(mini_diamond, cut, clarity, ext = id) %>% head(5)
```

- count two columns as a cross-tabulation table
```{r dataframe-cross_count}
cross_count(mini_diamond, cut, clarity)

# show the ratio in the row
cross_count(mini_diamond, cut, clarity, method = "rowr")

# show the ratio in the col
cross_count(mini_diamond, cut, clarity, method = "colr")
```

- split a column and return a longer tibble
```{r dataframe-split_column}
df <- fancy_count(mini_diamond, cut, ext = clarity) 
head(df)

split_column(df, name_col = cut, value_col = clarity)
```

- move selected rows to target location
```{r dataframe-rearrange_row}
# move row 3-5 after row 8
move_row(mini_diamond, 3:5, .after = 8)

# move row 3-5 before the first row
move_row(mini_diamond, 3:5, .before = TRUE)

# move row 3-5 after the last row
move_row(mini_diamond, 3:5, .after = TRUE)
```


- slice a tibble by an ordered vector
```{r dataframe-ordered_slice}
ordered_slice(mini_diamond, id, c("id-3", "id-2"))

# support NA and known values in ordered vector
ordered_slice(mini_diamond, id, c("id-3", "id-2", "unknown_id", "id-3", NA))

# remove NA
ordered_slice(mini_diamond, id, c("id-3", "id-2", "unknown_id", "id-3", NA),
  na.rm = TRUE
)

# remove duplication
ordered_slice(mini_diamond, id, c("id-3", "id-2", "unknown_id", "id-3", NA),
  dup.rm = TRUE
)
```

- remove columns by the ratio of NA, default to remove the columns only have NA
```{r dataframe-remove_nacol}
df_with_nacol <- dplyr::bind_cols(
  mini_diamond,
  tibble::tibble(na1 = NA, na2 = NA)
)
df_with_nacol

remove_nacol(df_with_nacol)

# remove the columns that have more than 20% NA values
# remove_nacol(df_with_nacol, max_ratio=0.2)
```

- remove rows by the ratio of NA
```{r dataframe-remove_narow}
# remove_narow(df)
```

- separate numeric vector into bins
```{r dataframe-hist_bins}
vector <- dplyr::pull(mini_diamond, price, id)

hist_bins(vector)

# set the max and min limits
hist_bins(vector, bins = 20, lim = c(0, 20000))

# or pass breaks directly
hist_bins(vector, breaks = seq(0, 20000, length.out = 11))
```

- trans a table in markdown format into tibble

``` {r dataframe-as_tibble_md}
x <- "
  | col1 | col2 | col3 |
  | ---- | ---- | ---- |
  | v1   | v2   | v3   |
  | r1   | r2   | r3   |
  "

as_tibble_md(x)
```

- trans a tibble into markdown format table

```{r dataframe-as_md_table}
mini_diamond %>%
  head(5) %>%
  as_md_table()
```


- relevel a target column by another reference column

```{r dataframe-ref_level}
cut_level <- mini_diamond %>%
  pull(cut) %>%
  unique()
df <- mini_diamond %>%
  dplyr::mutate(cut = factor(cut, cut_level)) %>%
  dplyr::mutate(cut0 = stringr::str_c(cut, "xxx"))

levels(df$cut)

levels(df$cut0)

# after relevel
df <- ref_level(df, cut0, cut)

levels(df$cut)

levels(df$cut0)
```




## stat
- statistical test which returns a extensible tibble
```{r stat-stat_test}
stat_test(mini_diamond, y = price, x = cut, .by = clarity)
```

- fold change calculation which returns a extensible tibble
```{r stat-stat_fc}
stat_fc(mini_diamond, y = price, x = cut, .by = clarity)
```

## IO
- get the command line arguments
```{r IO-cmdargs}
cmdargs()

cmdargs("R_env")
```

- detect whether directory is empty recursively, and detect 
whether file is empty recursively
```{r empty}
# create an empty directory
dir.create("some/deep/path/in/a/folder", recursive = TRUE)
empty_dir("some/deep/path/in/a/folder")

# create an empty file
file.create("some/deep/path/in/a/folder/there_is_a_file.txt")
empty_dir("some/deep/path/in/a/folder")
empty_file("some/deep/path/in/a/folder/there_is_a_file.txt", strict = TRUE)

# create a file with only character of length 0
write("", "some/deep/path/in/a/folder/there_is_a_file.txt")
empty_file("some/deep/path/in/a/folder/there_is_a_file.txt", strict = TRUE)
empty_file("some/deep/path/in/a/folder/there_is_a_file.txt")

# clean
unlink("some", recursive = TRUE)
```


- write a tibble, or a list of tibbles into an excel file
```{r IO-write_excel}
# write_excel(mini_diamond, "mini_diamond.xlsx")

# Ldf <- list(mini_diamond[1:3, ], mini_diamond[4:6, ])
# write_excel(Ldf, '2sheets.xlsx')
```

- fetch remote files via sftp
```{r IO-sftp}
# sftp_con <- sftp_connect(server='remote_host', port=22,
#                         user='username', password = "password", wd='~')
#
# sftp_download(sftp_con,
#    path=c('t1.txt', 't2.txt'),
#    to=c('path1.txt', 'path2.txt')
# )
```


## dev

- use aliases for function arguments
```{r dev-alias_arg}
# set y, z as aliases of x when create a function
func <- function(x = 1, y = NULL, z = NULL) {
  x <- alias_arg(x, y, with_default = x)
  return(x)
}

func()

x <- 8
func(x)

z <- 10
func(z)
```


## Code of Conduct
Please note that the baizer project is released with a [Contributor Code of Conduct](https://contributor-covenant.org/version/2/1/CODE_OF_CONDUCT.html). 
By contributing to this project, you agree to abide by its terms.
